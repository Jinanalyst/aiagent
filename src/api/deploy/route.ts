import { NextRequest, NextResponse } from 'next/server';
import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs';
import path from 'path';

const execAsync = promisify(exec);

// Platform-specific deployment functions
async function deployToVercel(tempDir: string) {
  // Check if user is logged into Vercel
  try {
    await execAsync('npx vercel whoami', { timeout: 10000 });
  } catch {
    throw new Error('Vercel authentication required. Please run "npx vercel login" in your terminal.');
  }

  const { stdout } = await execAsync(`cd "${tempDir}" && npx vercel --yes --prod`, {
    timeout: 300000 // 5 minutes timeout
  });

  const urlMatch = stdout.match(/https:\/\/[^\s]+/);
  const deploymentUrl = urlMatch ? urlMatch[0] : null;

  if (!deploymentUrl) {
    throw new Error('Could not extract deployment URL from Vercel output');
  }

  return deploymentUrl;
}

async function deployToNetlify(tempDir: string) {
  // Create netlify.toml configuration
  const netlifyConfig = `[build]
  command = "npm run build"
  publish = ".next"

[build.environment]
  NODE_VERSION = "18"

[[redirects]]
  from = "/*"
  to = "/index.html"
  status = 200`;

  await fs.promises.writeFile(path.join(tempDir, 'netlify.toml'), netlifyConfig);

  // Check if Netlify CLI is installed
  try {
    await execAsync('netlify --version', { timeout: 10000 });
  } catch {
    throw new Error('Netlify CLI not found. Please install it with "npm install -g netlify-cli" and run "netlify login".');
  }

  const { stdout } = await execAsync(`cd "${tempDir}" && netlify deploy --prod --dir=.next`, {
    timeout: 300000
  });

  const urlMatch = stdout.match(/https:\/\/[^\s]+/);
  const deploymentUrl = urlMatch ? urlMatch[0] : null;

  if (!deploymentUrl) {
    throw new Error('Could not extract deployment URL from Netlify output');
  }

  return deploymentUrl;
}

async function deployToRailway(tempDir: string) {
  // Create railway.json configuration
  const railwayConfig = {
    build: {
      builder: "NIXPACKS"
    },
    deploy: {
      startCommand: "npm start",
      healthcheckPath: "/",
      healthcheckTimeout: 300
    }
  };

  await fs.promises.writeFile(path.join(tempDir, 'railway.json'), JSON.stringify(railwayConfig, null, 2));

  // Check if Railway CLI is installed
  try {
    await execAsync('railway --version', { timeout: 10000 });
  } catch {
    throw new Error('Railway CLI not found. Please install it with "npm install -g @railway/cli" and run "railway login".');
  }

  const { stdout } = await execAsync(`cd "${tempDir}" && railway up --service`, {
    timeout: 300000
  });

  const urlMatch = stdout.match(/https:\/\/[^\s]+/);
  const deploymentUrl = urlMatch ? urlMatch[0] : null;

  if (!deploymentUrl) {
    throw new Error('Could not extract deployment URL from Railway output');
  }

  return deploymentUrl;
}

async function deployToGitHubPages(tempDir: string, projectName: string) {
  // For GitHub Pages, we need to create a static export
  // Update next.config.js for static export
  const nextConfig = `/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'export',
  trailingSlash: true,
  images: {
    unoptimized: true
  }
}

module.exports = nextConfig`;

  await fs.promises.writeFile(path.join(tempDir, 'next.config.js'), nextConfig);

  // Build the static export
  await execAsync(`cd "${tempDir}" && npm run build`, {
    timeout: 300000
  });

  // Create a simple deployment script
  const deployScript = `#!/bin/bash
# This is a placeholder for GitHub Pages deployment
# You'll need to:
# 1. Create a GitHub repository
# 2. Push this code to the repository
# 3. Enable GitHub Pages in repository settings
# 4. Set the source to the 'out' directory

echo "Static files generated in 'out' directory"
echo "Please follow GitHub Pages setup instructions in the README.md"`;

  await fs.promises.writeFile(path.join(tempDir, 'deploy.sh'), deployScript);
  await fs.promises.chmod(path.join(tempDir, 'deploy.sh'), 0o755);

  // Create README with GitHub Pages instructions
  const readme = `# ${projectName}

This project was generated by AI and is ready for GitHub Pages deployment.

## Deployment Instructions

1. Create a new GitHub repository
2. Push this code to your repository
3. Go to repository Settings > Pages
4. Set source to "Deploy from a branch"
5. Select "main" branch and "/out" folder
6. Click Save

Your site will be available at: https://yourusername.github.io/your-repo-name

## Local Development

\`\`\`bash
npm install
npm run dev
\`\`\`

## Build for Production

\`\`\`bash
npm run build
\`\`\`

The static files will be generated in the \`out\` directory.`;

  await fs.promises.writeFile(path.join(tempDir, 'README.md'), readme);

  return 'Static files generated. Please follow GitHub Pages setup instructions in README.md';
}

export async function POST(req: NextRequest) {
  try {
    const { fileSystem, projectName, platform = 'vercel' } = await req.json();

    if (!fileSystem || !projectName) {
      return NextResponse.json({ error: 'fileSystem and projectName are required' }, { status: 400 });
    }

    // Create a temporary directory for the project
    const tempDir = path.join(process.cwd(), 'temp', `project-${Date.now()}`);
    await fs.promises.mkdir(tempDir, { recursive: true });

    // Extract files to the temporary directory
    for (const [filePath, content] of Object.entries(fileSystem)) {
      const fullPath = path.join(tempDir, filePath.startsWith('/') ? filePath.substring(1) : filePath);
      const dir = path.dirname(fullPath);
      await fs.promises.mkdir(dir, { recursive: true });
      await fs.promises.writeFile(fullPath, content as string);
    }

    // Create a package.json if it doesn't exist
    const packageJsonPath = path.join(tempDir, 'package.json');
    if (!fs.existsSync(packageJsonPath)) {
      const defaultPackageJson = {
        name: projectName.toLowerCase().replace(/\s+/g, '-'),
        version: '0.1.0',
        private: true,
        scripts: {
          dev: 'next dev',
          build: 'next build',
          start: 'next start',
          lint: 'next lint'
        },
        dependencies: {
          react: '^18.0.0',
          'react-dom': '^18.0.0',
          next: '^14.0.0',
          typescript: '^5.0.0',
          '@types/node': '^20.0.0',
          '@types/react': '^18.0.0',
          '@types/react-dom': '^18.0.0',
          tailwindcss: '^3.0.0',
          autoprefixer: '^10.0.0',
          postcss: '^8.0.0'
        }
      };
      await fs.promises.writeFile(packageJsonPath, JSON.stringify(defaultPackageJson, null, 2));
    }

    // Create tailwind.config.js if it doesn't exist
    const tailwindConfigPath = path.join(tempDir, 'tailwind.config.js');
    if (!fs.existsSync(tailwindConfigPath)) {
      const tailwindConfig = `/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}`;
      await fs.promises.writeFile(tailwindConfigPath, tailwindConfig);
    }

    // Create postcss.config.js if it doesn't exist
    const postcssConfigPath = path.join(tempDir, 'postcss.config.js');
    if (!fs.existsSync(postcssConfigPath)) {
      const postcssConfig = `module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}`;
      await fs.promises.writeFile(postcssConfigPath, postcssConfig);
    }

    // Deploy based on platform
    let deploymentUrl: string;
    try {
      switch (platform) {
        case 'vercel':
          deploymentUrl = await deployToVercel(tempDir);
          break;
        case 'netlify':
          deploymentUrl = await deployToNetlify(tempDir);
          break;
        case 'railway':
          deploymentUrl = await deployToRailway(tempDir);
          break;
        case 'github':
          deploymentUrl = await deployToGitHubPages(tempDir, projectName);
          break;
        default:
          throw new Error(`Unsupported platform: ${platform}`);
      }

      // Clean up temporary directory
      await fs.promises.rm(tempDir, { recursive: true, force: true });

      return NextResponse.json({ 
        success: true, 
        deploymentUrl,
        platform,
        message: `Project deployed successfully to ${platform}!` 
      });

    } catch (deployError) {
      // Clean up on error
      await fs.promises.rm(tempDir, { recursive: true, force: true });
      throw deployError;
    }

  } catch (error) {
    console.error('Deployment error:', error);
    return NextResponse.json({ 
      error: 'Failed to deploy project',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
} 